{
  "version": 3,
  "sources": ["../../../../../../node_modules/object-assign-deep/objectAssignDeep.js"],
  "sourcesContent": ["'use strict';\n\n/*\n * OBJECT ASSIGN DEEP\n * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.\n */\n\n/*\n * A unified way of returning a string that describes the type of the given variable.\n */\nfunction getTypeOf (input) {\n\n\tif (input === null) {\n\t\treturn 'null';\n\t}\n\n\telse if (typeof input === 'undefined') {\n\t\treturn 'undefined';\n\t}\n\n\telse if (typeof input === 'object') {\n\t\treturn (Array.isArray(input) ? 'array' : 'object');\n\t}\n\n\treturn typeof input;\n\n}\n\n/*\n * Branching logic which calls the correct function to clone the given value base on its type.\n */\nfunction cloneValue (value) {\n\n\t// The value is an object so lets clone it.\n\tif (getTypeOf(value) === 'object') {\n\t\treturn quickCloneObject(value);\n\t}\n\n\t// The value is an array so lets clone it.\n\telse if (getTypeOf(value) === 'array') {\n\t\treturn quickCloneArray(value);\n\t}\n\n\t// Any other value can just be copied.\n\treturn value;\n\n}\n\n/*\n * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).\n */\nfunction quickCloneArray (input) {\n\treturn input.map(cloneValue);\n}\n\n/*\n * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of\n * its values cloned (i.e. references broken).\n */\nfunction quickCloneObject (input) {\n\n\tconst output = {};\n\n\tfor (const key in input) {\n\t\tif (!input.hasOwnProperty(key)) { continue; }\n\n\t\toutput[key] = cloneValue(input[key]);\n\t}\n\n\treturn output;\n\n}\n\n/*\n * Does the actual deep merging.\n */\nfunction executeDeepMerge (target, _objects = [], _options = {}) {\n\n\tconst options = {\n\t\tarrayBehaviour: _options.arrayBehaviour || 'replace',  // Can be \"merge\" or \"replace\".\n\t};\n\n\t// Ensure we have actual objects for each.\n\tconst objects = _objects.map(object => object || {});\n\tconst output = target || {};\n\n\t// Enumerate the objects and their keys.\n\tfor (let oindex = 0; oindex < objects.length; oindex++) {\n\t\tconst object = objects[oindex];\n\t\tconst keys = Object.keys(object);\n\n\t\tfor (let kindex = 0; kindex < keys.length; kindex++) {\n\t\t\tconst key = keys[kindex];\n\t\t\tconst value = object[key];\n\t\t\tconst type = getTypeOf(value);\n\t\t\tconst existingValueType = getTypeOf(output[key]);\n\n\t\t\tif (type === 'object') {\n\t\t\t\tif (existingValueType !== 'undefined') {\n\t\t\t\t\tconst existingValue = (existingValueType === 'object' ? output[key] : {});\n\t\t\t\t\toutput[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[key] = quickCloneObject(value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (type === 'array') {\n\t\t\t\tif (existingValueType === 'array') {\n\t\t\t\t\tconst newValue = quickCloneArray(value);\n\t\t\t\t\toutput[key] = (options.arrayBehaviour === 'merge' ? output[key].concat(newValue) : newValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[key] = quickCloneArray(value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\toutput[key] = value;\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn output;\n\n}\n\n/*\n * Merge all the supplied objects into the target object, breaking all references, including those of nested objects\n * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().\n * Properties in later objects will always overwrite.\n */\nmodule.exports = function objectAssignDeep (target, ...objects) {\n\treturn executeDeepMerge(target, objects);\n};\n\n/*\n * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.\n */\nmodule.exports.noMutate = function objectAssignDeepInto (...objects) {\n\treturn executeDeepMerge({}, objects);\n};\n\n/*\n * Allows an options object to be passed in to customise the behaviour of the function.\n */\nmodule.exports.withOptions = function objectAssignDeepInto (target, objects, options) {\n\treturn executeDeepMerge(target, objects, options);\n};\n"],
  "mappings": ";;;;;AAAA;AAAA;AAUA,aAAS,UAAW,OAAO;AAE1B,UAAI,UAAU,MAAM;AACnB,eAAO;AAAA,MACR,WAES,OAAO,UAAU,aAAa;AACtC,eAAO;AAAA,MACR,WAES,OAAO,UAAU,UAAU;AACnC,eAAQ,MAAM,QAAQ,KAAK,IAAI,UAAU;AAAA,MAC1C;AAEA,aAAO,OAAO;AAAA,IAEf;AAKA,aAAS,WAAY,OAAO;AAG3B,UAAI,UAAU,KAAK,MAAM,UAAU;AAClC,eAAO,iBAAiB,KAAK;AAAA,MAC9B,WAGS,UAAU,KAAK,MAAM,SAAS;AACtC,eAAO,gBAAgB,KAAK;AAAA,MAC7B;AAGA,aAAO;AAAA,IAER;AAKA,aAAS,gBAAiB,OAAO;AAChC,aAAO,MAAM,IAAI,UAAU;AAAA,IAC5B;AAMA,aAAS,iBAAkB,OAAO;AAEjC,YAAM,SAAS,CAAC;AAEhB,iBAAW,OAAO,OAAO;AACxB,YAAI,CAAC,MAAM,eAAe,GAAG,GAAG;AAAE;AAAA,QAAU;AAE5C,eAAO,GAAG,IAAI,WAAW,MAAM,GAAG,CAAC;AAAA,MACpC;AAEA,aAAO;AAAA,IAER;AAKA,aAAS,iBAAkB,QAAQ,WAAW,CAAC,GAAG,WAAW,CAAC,GAAG;AAEhE,YAAM,UAAU;AAAA,QACf,gBAAgB,SAAS,kBAAkB;AAAA;AAAA,MAC5C;AAGA,YAAM,UAAU,SAAS,IAAI,YAAU,UAAU,CAAC,CAAC;AACnD,YAAM,SAAS,UAAU,CAAC;AAG1B,eAAS,SAAS,GAAG,SAAS,QAAQ,QAAQ,UAAU;AACvD,cAAM,SAAS,QAAQ,MAAM;AAC7B,cAAM,OAAO,OAAO,KAAK,MAAM;AAE/B,iBAAS,SAAS,GAAG,SAAS,KAAK,QAAQ,UAAU;AACpD,gBAAM,MAAM,KAAK,MAAM;AACvB,gBAAM,QAAQ,OAAO,GAAG;AACxB,gBAAM,OAAO,UAAU,KAAK;AAC5B,gBAAM,oBAAoB,UAAU,OAAO,GAAG,CAAC;AAE/C,cAAI,SAAS,UAAU;AACtB,gBAAI,sBAAsB,aAAa;AACtC,oBAAM,gBAAiB,sBAAsB,WAAW,OAAO,GAAG,IAAI,CAAC;AACvE,qBAAO,GAAG,IAAI,iBAAiB,CAAC,GAAG,CAAC,eAAe,iBAAiB,KAAK,CAAC,GAAG,OAAO;AAAA,YACrF,OACK;AACJ,qBAAO,GAAG,IAAI,iBAAiB,KAAK;AAAA,YACrC;AAAA,UACD,WAES,SAAS,SAAS;AAC1B,gBAAI,sBAAsB,SAAS;AAClC,oBAAM,WAAW,gBAAgB,KAAK;AACtC,qBAAO,GAAG,IAAK,QAAQ,mBAAmB,UAAU,OAAO,GAAG,EAAE,OAAO,QAAQ,IAAI;AAAA,YACpF,OACK;AACJ,qBAAO,GAAG,IAAI,gBAAgB,KAAK;AAAA,YACpC;AAAA,UACD,OAEK;AACJ,mBAAO,GAAG,IAAI;AAAA,UACf;AAAA,QAED;AAAA,MACD;AAEA,aAAO;AAAA,IAER;AAOA,WAAO,UAAU,SAAS,iBAAkB,WAAW,SAAS;AAC/D,aAAO,iBAAiB,QAAQ,OAAO;AAAA,IACxC;AAKA,WAAO,QAAQ,WAAW,SAAS,wBAAyB,SAAS;AACpE,aAAO,iBAAiB,CAAC,GAAG,OAAO;AAAA,IACpC;AAKA,WAAO,QAAQ,cAAc,SAAS,qBAAsB,QAAQ,SAAS,SAAS;AACrF,aAAO,iBAAiB,QAAQ,SAAS,OAAO;AAAA,IACjD;AAAA;AAAA;",
  "names": []
}
